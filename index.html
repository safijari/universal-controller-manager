<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Pico Controller Manager</title>
  <style>
    :root {
      --bg: #edf2f8;
      --card: #fff;
      --line: #d5dfeb;
      --text: #1f2b3a;
      --muted: #5e6d83;
      --accent: #0d62c9;
      --ok: #0a8a55;
      --warn: #b93426;
      --drag: #fff0cf;
    }
    * { box-sizing: border-box; }
    body { margin: 0; background: radial-gradient(circle at top left, #dce8f8, #f7fafd 62%); color: var(--text); font-family: "IBM Plex Sans", "Segoe UI", sans-serif; }
    main { max-width: 1160px; margin: 0 auto; padding: 10px; }
    .card { background: var(--card); border: 1px solid var(--line); border-radius: 10px; padding: 10px; margin-bottom: 10px; }
    h1, h2 { margin: 0 0 8px; }
    h1 { font-size: 1.45rem; }
    h2 { font-size: 1rem; color: var(--muted); }
    .meta, .small { color: var(--muted); font-size: .85rem; }
    .small { font-size: .84rem; }
    .row { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 10px; }
    @media (min-width: 900px) { .grid.two { grid-template-columns: 1fr 1fr; } }
    @media (min-width: 1100px) { .grid.three { grid-template-columns: 1fr 1fr 1fr; } }
    input, select { border: 1px solid var(--line); border-radius: 8px; padding: 6px 8px; min-height: 32px; }
    input[type="text"], input[type="password"] { min-width: 220px; }
    button { border: 0; border-radius: 8px; padding: 7px 10px; min-height: 32px; cursor: pointer; background: #dfe8f7; font-weight: 600; }
    button.primary { background: var(--accent); color: #fff; }
    button.ok { background: var(--ok); color: #fff; }
    button.warn { background: var(--warn); color: #fff; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .pill { border-radius: 999px; padding: 3px 8px; font-size: .8rem; background: #e6edf7; }
    .pill.ok { background: #dbf4e8; color: #0e6d45; }
    .pill.off { background: #f7e3e0; color: #8b2e24; }
    .mono { font-family: "IBM Plex Mono", monospace; }
    .error { color: #a52317; font-size: .88rem; }
    ul { margin: 8px 0 0; padding-left: 18px; }
    li { margin: 4px 0; }
    .slot-list { list-style: none; padding: 0; margin: 8px 0 0; }
    .slot-item { border: 1px solid var(--line); border-radius: 8px; background: #f9fcff; padding: 10px; margin-bottom: 8px; cursor: grab; }
    .slot-item.over { background: var(--drag); border-color: #d3a039; }
    .slot-top { display: flex; justify-content: space-between; align-items: center; gap: 8px; }
    .logbox { border: 1px solid var(--line); border-radius: 8px; background: #f7fbff; max-height: 220px; overflow: auto; padding: 8px; font-size: .8rem; line-height: 1.35; }
    .pads { display: grid; grid-template-columns: 1fr; gap: 8px; }
    @media (min-width: 900px) { .pads { grid-template-columns: 1fr 1fr; } }
    .pad { border: 1px solid var(--line); border-radius: 8px; padding: 8px; background: #f9fcff; }
    .pad h3 { margin: 0 0 6px; font-size: .95rem; }
    .pad .row button { padding: 5px 8px; min-height: 28px; font-size: .82rem; }
  </style>
</head>
<body>
<main>
  <div class="card">
    <h1>Pico Controller Manager</h1>
    <div class="meta">Full pairing control, drag/drop slot order, reactive status, USB output mode, Wi-Fi credentials, and BLE panel.</div>
  </div>

  <div class="card">
    <h2>Connection + Transport</h2>
    <div class="grid three">
      <div>
        <div class="row">
          <label for="baseUrl">Device URL</label>
          <input id="baseUrl" type="text" value="http://10.10.10.1">
          <button id="saveUrlBtn">Save</button>
        </div>
        <div class="row" style="margin-top:6px">
          <label for="controlVia">Control via</label>
          <select id="controlVia">
            <option value="auto">Auto</option>
            <option value="wifi">Wi-Fi</option>
            <option value="ble">Bluetooth</option>
          </select>
          <button id="testBtn" class="primary">Test</button>
          <button id="pollBtn" class="ok">Polling On</button>
        </div>
      </div>
      <div>
        <div class="row">
          <select id="modeSelect">
            <option value="xinput">xinput</option>
            <option value="switch">switch</option>
            <option value="dinput">dinput</option>
            <option value="ps3">ps3</option>
            <option value="ps4">ps4</option>
            <option value="hid">hid</option>
          </select>
          <button id="modeSetBtn" class="primary">Set Mode</button>
          <button id="usbWakeBtn">Wake Host</button>
          <button id="usbSleepBtn">Sleep Host</button>
        </div>
        <div class="row" style="margin-top:6px">
          <span>Switch AB/XY: <span id="switchSwapState" class="pill">-</span></span>
          <button id="swapOnBtn">Swap On</button>
          <button id="swapOffBtn">Swap Off</button>
        </div>
        <div class="small" id="modeNow" style="margin-top:6px">Current: -</div>
      </div>
      <div>
        <div class="small">Current SSID: <span id="wifiSsid" class="mono">-</span> | Connected: <span id="wifiSta" class="pill">-</span></div>
        <div class="row" style="margin-top:6px">
          <input id="wifiSsidIn" type="text" placeholder="SSID">
          <input id="wifiPassIn" type="password" placeholder="Password">
        </div>
        <div class="row" style="margin-top:6px">
          <button id="wifiSetBtn" class="primary">Save Wi-Fi</button>
          <button id="wifiReconnectBtn">Reconnect STA</button>
        </div>
      </div>
    </div>
    <div style="margin-top:8px; padding-top:8px; border-top:1px solid var(--line);">
      <div class="row">
        <strong>BLE Connection</strong>
        <button id="bleConnectBtn">Connect BLE</button>
        <button id="bleDisconnectBtn">Disconnect BLE</button>
        <button id="bleRefreshBtn">Refresh BLE</button>
      </div>
      <div class="small" style="margin-top:6px">Connected controllers (BLE service):</div>
      <ul id="bleControllers"></ul>
    </div>
    <div class="row" style="margin-top:8px">
      <span>HTTP: <span id="httpState" class="pill off">Offline</span></span>
      <span>BLE: <span id="bleState" class="pill off">Disconnected</span></span>
      <span>USB: <span id="usbState" class="pill">-</span></span>
      <span>Uptime: <span id="uptime" class="mono">-</span></span>
      <span>Build: <span id="build" class="mono">-</span></span>
      <span id="lastUpdate" class="small">Last update: -</span>
    </div>
    <div id="error" class="error" style="margin-top:6px"></div>
  </div>

  <div class="card">
    <h2>Mouse + Keyboard Mode</h2>
    <div class="small">Works in all output modes; sends keyboard/mouse as an extra USB HID interface.</div>
    <div class="row" style="margin-top:8px">
      <button id="captureBtn">Capture Desktop Input</button>
      <button id="releaseCaptureBtn">Release Capture</button>
      <button id="leftClickBtn">Left Click</button>
      <button id="rightClickBtn">Right Click</button>
      <button id="middleClickBtn">Middle Click</button>
    </div>
    <div class="row" style="margin-top:8px">
      <input id="mkTextIn" type="text" placeholder="Type text to send">
      <button id="mkSendTextBtn" class="primary">Send Text</button>
    </div>
    <div id="touchpad" style="margin-top:10px; border:1px solid var(--line); border-radius:10px; height:170px; background:#f4f8ff; display:flex; align-items:center; justify-content:center; user-select:none; touch-action:none;">
      Touchpad: drag to move pointer, two-finger vertical drag to scroll
    </div>
  </div>

  <div class="card">
    <h2>Wake-on-LAN</h2>
    <div class="row">
      <input id="wolNameIn" type="text" placeholder="Machine name">
      <input id="wolMacIn" type="text" placeholder="AA:BB:CC:DD:EE:FF">
      <button id="wolAddBtn" class="primary">Add Machine</button>
      <button id="wolSendFirstBtn">Send WOL (First)</button>
      <button id="wolWakeBtn">Wake Host (F13 + WOL)</button>
    </div>
    <div class="small" style="margin-top:8px">Guide + LT + RT also sends F13 and WOL to the first machine.</div>
    <ul id="wolList"></ul>
  </div>

  <div class="grid">
    <div class="card">
      <h2>Pairing Control</h2>
      <div class="row">
        <button id="scanOnBtn" class="ok">Start Scan</button>
        <button id="scanOffBtn">Stop Scan</button>
        <button id="scanClearBtn">Clear Found</button>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="autoOnBtn">Auto On</button>
        <button id="autoOffBtn">Auto Off</button>
        <button id="showOnBtn">Show-All On</button>
        <button id="showOffBtn">Show-All Off</button>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="pairListBtn">List Pairings</button>
        <button id="pairClearBtn" class="warn">Clear Pairings</button>
      </div>
      <div class="small" id="btFlags" style="margin-top:8px">Scan: - | Auto: - | Show-All: -</div>
    </div>
  </div>

  <div class="grid two">
    <div class="card">
      <h2>Connected Devices</h2>
      <ul id="connectedDevicesList"></ul>
      <h2 style="margin-top:12px">Discovered Devices</h2>
      <ul id="devices"></ul>
    </div>

    <div class="card">
      <h2>Paired Devices</h2>
      <ul id="paired"></ul>
      <h2 style="margin-top:10px">Wi-Fi Clients</h2>
      <ul id="wifiClients"></ul>
    </div>
  </div>

  <div class="card">
    <h2>Controller Slots (Drag & Drop)</h2>
    <div class="small">Drag BT slots to reorder priority/mapping.</div>
    <ul id="slots" class="slot-list"></ul>
  </div>

  <div class="card">
    <h2>Hosted UI Controls</h2>
    <div class="small">Quick virtual button taps for C1-C4 (same endpoints as built-in page).</div>
    <div id="controllerPads" class="pads" style="margin-top:8px"></div>
  </div>

  <div class="card">
    <div class="row" style="justify-content:space-between">
      <h2 style="margin:0">Live Logs</h2>
      <div class="row">
        <button id="logPauseBtn">Pause</button>
        <button id="logClearBtn">Clear</button>
      </div>
    </div>
    <div id="logMeta" class="small">Logs stream from `/status` (Wi-Fi transport).</div>
    <div id="logBox" class="logbox mono" style="margin-top:8px"></div>
  </div>
</main>

<script>
const MODE_BY_ID = {0:"xinput",1:"hid",2:"switch",3:"dinput",4:"ps3",5:"ps4",6:"xinput",7:"xinput",8:"xinput"};
const UUIDS = {
  service: "4627c4a4-ac00-46b9-b688-afc5c1bf7f63",
  connectedDevices: "4627c4a4-ac05-46b9-b688-afc5c1bf7f63",
  command: "4627c4a4-ac09-46b9-b688-afc5c1bf7f63",
};
const BLE_NAME_PREFIXES = ["WiCaTS", "pico_w_xinput", "Bluepad32", "Pico W"];
const $ = (id) => document.getElementById(id);
const esc = (s) => String(s ?? "").replace(/[&<>\"]/g, (m) => ({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[m]));

let baseUrl = normalizeBaseUrl(localStorage.getItem("pico_manager_url") || "http://10.10.10.1");
let controlVia = localStorage.getItem("pico_manager_via") || "auto";
let state = null;
let pollEnabled = true;
let pollTimer = null;
let pollInFlight = false;
let dragFromSlot = null;
let httpOnline = false;
let blePollCounter = 0;
let logsPaused = false;
let modeSelectDirty = false;
let modeSetPending = "";

let bleDevice = null;
let bleServer = null;
let bleChars = {};
let bleOpQueue = Promise.resolve();
let bleManualDisconnect = false;
let bleAutoReconnectTimer = null;
let bleLastAutoAttemptMs = 0;
let bleReconnectBackoffMs = 1200;
const BLE_LAST_DEVICE_KEY = "pico_manager_ble_device_id";
const LOG_STORE_KEY = "pico_manager_logs_v2";
const LOG_MAX = 2000;
const LOG_RENDER_MAX = 220;
let logLines = [];
let lastLogSeq = 0;
const VIRTUAL_BUTTONS = [
  ["A", 0], ["B", 1], ["X", 2], ["Y", 3], ["LB", 4], ["RB", 5],
  ["LT", 6], ["RT", 7], ["Back", 8], ["Start", 9], ["LS", 10], ["RS", 11],
  ["DPad Up", 12], ["DPad Down", 13], ["DPad Left", 14], ["DPad Right", 15], ["Home", 16],
];

function bleSerialize(task) {
  const run = bleOpQueue.then(task, task);
  bleOpQueue = run.catch(() => {});
  return run;
}

function clearBleAutoReconnectTimer() {
  if (bleAutoReconnectTimer) {
    clearTimeout(bleAutoReconnectTimer);
    bleAutoReconnectTimer = null;
  }
}

function scheduleBleAutoReconnect(delayMs = 1500) {
  if (bleManualDisconnect) return;
  clearBleAutoReconnectTimer();
  bleAutoReconnectTimer = setTimeout(bleAutoReconnectTick, Math.max(250, delayMs | 0));
}

async function bleAutoReconnectTick() {
  if (bleManualDisconnect || bleIsConnected()) {
    clearBleAutoReconnectTimer();
    return;
  }
  if (!bleAutoReconnectSupported()) return;

  const now = Date.now();
  if ((now - bleLastAutoAttemptMs) < 300) {
    scheduleBleAutoReconnect(300);
    return;
  }
  bleLastAutoAttemptMs = now;

  let ok = false;
  try {
    ok = await bleTryAutoConnect();
  } catch (_) {
    ok = false;
  }

  if (ok) {
    bleReconnectBackoffMs = 1200;
    setError("");
    try {
      await refreshState(true);
      renderAll();
      await bleRefreshPanel();
    } catch (_) {}
    return;
  }

  bleReconnectBackoffMs = Math.min(15000, Math.floor(bleReconnectBackoffMs * 1.6));
  scheduleBleAutoReconnect(bleReconnectBackoffMs);
}

function setError(msg) { $("error").textContent = msg || ""; }
function setHttpOnline(on) {
  httpOnline = !!on;
  const e = $("httpState");
  e.textContent = on ? "Online" : "Offline";
  e.className = on ? "pill ok" : "pill off";
}
function setBleOnline(on) {
  const e = $("bleState");
  e.textContent = on ? "Connected" : "Disconnected";
  e.className = on ? "pill ok" : "pill off";
}
function bleIsConnected() {
  return !!(bleDevice && bleDevice.gatt && bleDevice.gatt.connected && bleServer && bleChars.command);
}

function bleAutoReconnectSupported() {
  return !!(navigator.bluetooth && typeof navigator.bluetooth.getDevices === "function");
}

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function ensureStateDefaults() {
  if (state) return;
  state = {
    build: "-",
    log_first_seq: 0,
    logs: [],
    uptime_s: 0,
    bt: {
      scan: false,
      show_all: false,
      auto: false,
      pairing: false,
      usb: {},
      slots: [],
      devices: [],
      paired: [],
    },
    wifi: {
      ap: false,
      clients: [],
      sta_connected: false,
      sta_ssid: "",
    },
    wol: {
      machines: [],
    },
    controllers: [],
  };
}

function normalizeBaseUrl(raw) {
  let v = String(raw || "").trim();
  if (!v) return "http://10.10.10.1";
  if (!/^https?:\/\//i.test(v)) {
    v = `${location.protocol === "https:" ? "https" : "http"}://${v}`;
  }
  return v.replace(/\/$/, "");
}

function isMixedContentBlocked() {
  return location.protocol === "https:" && /^http:\/\//i.test(baseUrl);
}

async function apiFetch(path, timeout = 4000) {
  if (isMixedContentBlocked()) {
    throw new Error("Mixed content blocked: use https:// Device URL (e.g. ngrok) or BLE transport.");
  }
  const ac = new AbortController();
  const t = setTimeout(() => ac.abort(), timeout);
  try {
    return await fetch(`${baseUrl}${path}`, {method: "GET", mode: "cors", cache: "no-store", signal: ac.signal});
  } catch (e) {
    if (e && e.name === "AbortError") {
      throw new Error("Request timed out");
    }
    throw e;
  } finally {
    clearTimeout(t);
  }
}

async function httpStatusFetch() {
  const r = await apiFetch("/status");
  if (!r.ok) throw new Error(`HTTP ${r.status}`);
  return await r.json();
}

async function httpCmd(path) {
  const r = await apiFetch(path);
  if (!r.ok) throw new Error(`HTTP ${r.status}`);
  return {ok: 1};
}

async function bleCommand(path) {
  return bleSerialize(async () => {
    if (!bleIsConnected()) {
      await bleTryAutoConnect().catch(() => {});
    }
    if (!bleIsConnected()) throw new Error("BLE not connected");
    const payload = new TextEncoder().encode(path);
    await bleChars.command.writeValue(payload);
    const raw = await bleChars.command.readValue();
    const view = new Uint8Array(raw.buffer, raw.byteOffset, raw.byteLength);
    const text = new TextDecoder().decode(view).trim();
    if (!text) return {};
    try {
      return JSON.parse(text);
    } catch (e) {
      throw new Error(`Invalid BLE response: ${text}`);
    }
  });
}

function onBleDisconnected() {
  setBleOnline(false);
  renderBleControllers([]);
  bleServer = null;
  bleChars = {};
  if (!bleManualDisconnect) {
    bleReconnectBackoffMs = 1200;
    scheduleBleAutoReconnect(bleReconnectBackoffMs);
  }
}

async function bleAttach(device) {
  if (!device) throw new Error("No BLE device");
  clearBleAutoReconnectTimer();
  bleReconnectBackoffMs = 1200;

  if (bleDevice && bleDevice !== device) {
    bleDevice.removeEventListener("gattserverdisconnected", onBleDisconnected);
  }
  bleDevice = device;
  bleDevice.removeEventListener("gattserverdisconnected", onBleDisconnected);
  bleDevice.addEventListener("gattserverdisconnected", onBleDisconnected);

  if (bleDevice.gatt.connected) {
    bleServer = bleDevice.gatt;
  } else {
    let lastErr = null;
    for (let i = 0; i < 3; i++) {
      try {
        bleServer = await bleDevice.gatt.connect();
        break;
      } catch (e) {
        lastErr = e;
        await sleep(250);
      }
    }
    if (!bleServer) throw lastErr || new Error("BLE connect failed");
  }

  const svc = await bleServer.getPrimaryService(UUIDS.service);
  bleChars.connectedDevices = await svc.getCharacteristic(UUIDS.connectedDevices);
  bleChars.command = await svc.getCharacteristic(UUIDS.command);

  try {
    localStorage.setItem(BLE_LAST_DEVICE_KEY, bleDevice.id || "");
  } catch (_) {}

  setBleOnline(true);
  await bleRefreshPanel();
  if ($("controlVia").value !== "wifi") {
    await refreshState(true);
    renderAll();
  }
}

async function bleTryAutoConnect() {
  if (!bleAutoReconnectSupported()) {
    return false;
  }
  if (bleIsConnected()) return true;

  let devices = [];
  try {
    devices = await navigator.bluetooth.getDevices();
  } catch (_) {
    return false;
  }
  if (!devices || !devices.length) return false;

  const preferredId = localStorage.getItem(BLE_LAST_DEVICE_KEY) || "";
  const ordered = preferredId
    ? [
        ...devices.filter((d) => d.id === preferredId),
        ...devices.filter((d) => d.id !== preferredId),
      ]
    : devices;

  for (const d of ordered) {
    try {
      await bleAttach(d);
      return true;
    } catch (_) {
      // Try next remembered device
    }
  }
  return false;
}

function mergeBleState(status, slots, devices, paired) {
  const bt = {
    scan: !!status?.bt?.scan,
    show_all: !!status?.bt?.show_all,
    auto: !!status?.bt?.auto,
    pairing: !!status?.bt?.pairing,
    usb: status?.usb || {},
    slots: slots?.slots || [],
    devices: devices?.devices || state?.bt?.devices || [],
    paired: paired?.paired || state?.bt?.paired || [],
  };
  return {
    build: status?.build || state?.build || "-",
    log_first_seq: state?.log_first_seq || 0,
    logs: state?.logs || [],
    uptime_s: status?.uptime_s ?? state?.uptime_s ?? 0,
    bt,
    wifi: {
      ap: state?.wifi?.ap || false,
      clients: state?.wifi?.clients || [],
      sta_connected: !!status?.wifi?.sta_connected,
      sta_ssid: status?.wifi?.sta_ssid || "",
    },
    wol: {
      machines: status?.wol?.machines || state?.wol?.machines || [],
    },
    controllers: state?.controllers || [],
  };
}

async function bleStatusFetch(full) {
  const status = await bleCommand("/ble/status");
  const slots = await bleCommand("/ble/slots");
  let devices = null;
  let paired = null;
  blePollCounter++;
  if (full || (blePollCounter % 3) === 0 || !state?.bt?.devices || !state?.bt?.paired) {
    devices = await bleCommand("/ble/devices");
    paired = await bleCommand("/ble/paired");
  }
  return mergeBleState(status, slots, devices, paired);
}

function effectiveTransport() {
  const v = $("controlVia").value;
  if (v === "wifi") return "wifi";
  if (v === "ble") return "ble";
  if (isMixedContentBlocked()) return "ble";
  if (httpOnline) return "wifi";
  if (bleIsConnected()) return "ble";
  return "wifi";
}

async function runCmd(path) {
  const via = effectiveTransport();
  if (via === "ble") {
    const res = await bleCommand(path);
    if (res && res.ok === 0) throw new Error(res.err || "BLE command failed");
    return res;
  }
  return await httpCmd(path);
}

let captureActive = false;
const capturePressed = new Set();
let mkMotionDx = 0;
let mkMotionDy = 0;
let mkMotionWheel = 0;
let mkFlushBusy = false;
let lastMouseX = null;
let lastMouseY = null;
const touchPoints = new Map();
let touchLastY = null;

const KEY_MAP = {
  Escape: 0x29,
  Enter: 0x28,
  NumpadEnter: 0x58,
  Backspace: 0x2A,
  Tab: 0x2B,
  Space: 0x2C,
  ArrowRight: 0x4F,
  ArrowLeft: 0x50,
  ArrowDown: 0x51,
  ArrowUp: 0x52,
  Home: 0x4A,
  End: 0x4D,
  PageUp: 0x4B,
  PageDown: 0x4E,
  Insert: 0x49,
  Delete: 0x4C,
  F1: 0x3A, F2: 0x3B, F3: 0x3C, F4: 0x3D, F5: 0x3E, F6: 0x3F,
  F7: 0x40, F8: 0x41, F9: 0x42, F10: 0x43, F11: 0x44, F12: 0x45,
  F13: 0x68,
  Minus: 0x2D, Equal: 0x2E, BracketLeft: 0x2F, BracketRight: 0x30,
  Backslash: 0x31, Semicolon: 0x33, Quote: 0x34, Backquote: 0x35,
  Comma: 0x36, Period: 0x37, Slash: 0x38,
};

function keyModsFromEvent(e) {
  return (e.ctrlKey ? 0x01 : 0) |
         (e.shiftKey ? 0x02 : 0) |
         (e.altKey ? 0x04 : 0) |
         (e.metaKey ? 0x08 : 0);
}

function hidCodeFromEventCode(code) {
  if (code && code.startsWith("Key") && code.length === 4) {
    const c = code.charCodeAt(3);
    if (c >= 65 && c <= 90) return 0x04 + (c - 65);
  }
  if (code && code.startsWith("Digit") && code.length === 6) {
    const n = code.charCodeAt(5) - 48;
    if (n >= 1 && n <= 9) return 0x1E + (n - 1);
    if (n === 0) return 0x27;
  }
  if (code && code.startsWith("Numpad")) {
    const n = code.charCodeAt(code.length - 1) - 48;
    if (n >= 0 && n <= 9) return 0x59 + n;
  }
  return KEY_MAP[code] || 0;
}

async function mkSendKey(code, mods, down) {
  if (!code) return;
  await runCmd(`/mk/key?code=${code}&mod=${mods}&down=${down ? 1 : 0}`);
}

async function mkSendText(text) {
  const t = (text || "").trim();
  if (!t) return;
  const chunkSize = 40;
  for (let i = 0; i < t.length; i += chunkSize) {
    const chunk = t.slice(i, i + chunkSize);
    await runCmd(`/mk/text?t=${encodeURIComponent(chunk)}`);
  }
}

function mkQueueMotion(dx, dy, wheel = 0) {
  mkMotionDx += dx || 0;
  mkMotionDy += dy || 0;
  mkMotionWheel += wheel || 0;
}

async function mkFlushMotion() {
  if (mkFlushBusy) return;
  mkFlushBusy = true;
  try {
    const dx = Math.max(-127, Math.min(127, Math.trunc(mkMotionDx)));
    const dy = Math.max(-127, Math.min(127, Math.trunc(mkMotionDy)));
    const wh = Math.max(-127, Math.min(127, Math.trunc(mkMotionWheel)));
    mkMotionDx -= dx;
    mkMotionDy -= dy;
    mkMotionWheel -= wh;
    if (dx || dy) {
      await runCmd(`/mk/move?dx=${dx}&dy=${dy}`);
    }
    if (wh) {
      await runCmd(`/mk/wheel?v=${wh}`);
    }
  } catch (_) {
    // Keep UI responsive if input streaming temporarily fails.
  } finally {
    mkFlushBusy = false;
  }
}

async function mkClick(button) {
  await runCmd(`/mk/button?btn=${button}&down=1`);
  await runCmd(`/mk/button?btn=${button}&down=0`);
}

function mapMouseButton(button) {
  if (button === 0) return 1;
  if (button === 1) return 3;
  if (button === 2) return 2;
  return 0;
}

function captureKeyDown(e) {
  if (!captureActive) return;
  if (e.repeat) return;
  const code = hidCodeFromEventCode(e.code);
  if (!code) return;
  capturePressed.add(e.code);
  const mods = keyModsFromEvent(e);
  e.preventDefault();
  runWrap(() => mkSendKey(code, mods, true));
}

function captureKeyUp(e) {
  if (!captureActive) return;
  if (!capturePressed.has(e.code)) return;
  capturePressed.delete(e.code);
  const code = hidCodeFromEventCode(e.code);
  if (!code) return;
  const mods = keyModsFromEvent(e);
  e.preventDefault();
  runWrap(() => mkSendKey(code, mods, false));
}

function captureMouseMove(e) {
  if (!captureActive) return;
  let dx = e.movementX || 0;
  let dy = e.movementY || 0;
  if (dx === 0 && dy === 0 && lastMouseX != null && lastMouseY != null) {
    dx = e.clientX - lastMouseX;
    dy = e.clientY - lastMouseY;
  }
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;
  if (dx || dy) mkQueueMotion(dx, dy, 0);
}

function captureMouseWheel(e) {
  if (!captureActive) return;
  e.preventDefault();
  const step = Math.max(-24, Math.min(24, Math.round(-e.deltaY / 8)));
  if (step) mkQueueMotion(0, 0, step);
}

function captureMouseButton(e, down) {
  if (!captureActive) return;
  const btn = mapMouseButton(e.button);
  if (!btn) return;
  e.preventDefault();
  runWrap(() => runCmd(`/mk/button?btn=${btn}&down=${down ? 1 : 0}`));
}

async function stopCapture() {
  captureActive = false;
  for (const codeStr of [...capturePressed]) {
    const code = hidCodeFromEventCode(codeStr);
    if (code) {
      await mkSendKey(code, 0, false);
    }
  }
  capturePressed.clear();
  lastMouseX = null;
  lastMouseY = null;
}

function averageTouchY() {
  let sum = 0;
  let count = 0;
  for (const p of touchPoints.values()) {
    sum += p.y;
    count++;
  }
  return count ? (sum / count) : null;
}

function touchpadDown(e) {
  const pad = $("touchpad");
  if (pad.setPointerCapture) pad.setPointerCapture(e.pointerId);
  touchPoints.set(e.pointerId, {x: e.clientX, y: e.clientY});
  if (touchPoints.size < 2) touchLastY = null;
  e.preventDefault();
}

function touchpadMove(e) {
  const prev = touchPoints.get(e.pointerId);
  if (!prev) return;
  const now = {x: e.clientX, y: e.clientY};
  touchPoints.set(e.pointerId, now);
  if (touchPoints.size >= 2) {
    const avgY = averageTouchY();
    if (avgY != null && touchLastY != null) {
      const step = Math.max(-24, Math.min(24, Math.round((touchLastY - avgY) / 3)));
      if (step) mkQueueMotion(0, 0, step);
    }
    touchLastY = avgY;
  } else {
    mkQueueMotion(now.x - prev.x, now.y - prev.y, 0);
  }
  e.preventDefault();
}

function touchpadUp(e) {
  touchPoints.delete(e.pointerId);
  if (touchPoints.size < 2) touchLastY = null;
  e.preventDefault();
}

function updateTop() {
  if (!state) return;
  $("uptime").textContent = `${state.uptime_s ?? "-"}s`;
  $("build").textContent = state.build || "-";
  const mounted = !!state.bt?.usb?.mounted;
  $("usbState").textContent = mounted ? "Mounted" : "Not mounted";
  $("usbState").className = mounted ? "pill ok" : "pill";
  const rawMode = state.bt?.usb?.mode;
  const mode = (typeof rawMode === "string") ? rawMode : (MODE_BY_ID[rawMode] || "xinput");
  if (modeSetPending && mode === modeSetPending) {
    modeSetPending = "";
    modeSelectDirty = false;
  }
  if (!modeSelectDirty && !modeSetPending) {
    $("modeSelect").value = mode;
  }
  $("modeNow").textContent = `Current: ${mode}`;
  const swap = !!state.bt?.usb?.switch_swap;
  $("switchSwapState").textContent = swap ? "On" : "Off";
  $("switchSwapState").className = swap ? "pill ok" : "pill";
  $("btFlags").textContent = `Scan: ${state.bt?.scan ? "On" : "Off"} | Auto: ${state.bt?.auto ? "On" : "Off"} | Show-All: ${state.bt?.show_all ? "On" : "Off"}`;
  $("wifiSsid").textContent = state.wifi?.sta_ssid || "-";
  const sta = !!state.wifi?.sta_connected;
  $("wifiSta").textContent = sta ? "Connected" : "Disconnected";
  $("wifiSta").className = sta ? "pill ok" : "pill off";
  $("lastUpdate").textContent = `Last update: ${new Date().toLocaleTimeString()}`;
}

function renderDevices() {
  const {connected, discovered} = splitDevicesByConnection();
  renderConnectedDevices(connected);

  const ul = $("devices");
  ul.innerHTML = "";
  if (!discovered.length) { ul.innerHTML = "<li>None</li>"; return; }
  discovered.forEach((d, i) => {
    const idx = d.idx ?? i;
    const li = document.createElement("li");
    li.innerHTML = `${esc(d.name || "Unknown")} <span class="mono">${esc(d.addr)}</span> (RSSI ${d.rssi}, last ${d.last_s}s)`;
    const row = document.createElement("div"); row.className = "row";
    const c = document.createElement("button"); c.textContent = "Connect"; c.onclick = () => runWrap(async () => { await runCmd(`/bt/connect/${idx}`); await refreshState(true); });
    const r = document.createElement("button"); r.textContent = "Repair"; r.onclick = () => runWrap(async () => { await runCmd(`/bt/repair/${idx}`); await refreshState(true); });
    row.appendChild(c); row.appendChild(r);
    li.appendChild(row); ul.appendChild(li);
  });
}

function splitDevicesByConnection() {
  const slots = state?.bt?.slots || [];
  const devices = state?.bt?.devices || [];
  const connectedByAddr = new Map();

  slots.forEach((s) => {
    if (!s?.connected || !s.addr) return;
    const key = String(s.addr).toUpperCase();
    connectedByAddr.set(key, {
      addr: s.addr,
      name: s.name || "Unknown",
      rssi: "-",
      last_s: s.last_s ?? 0,
      slot: s.map,
      ble: !!s.ble,
      idx: null,
    });
  });

  devices.forEach((d, i) => {
    if (!d?.addr) return;
    const key = String(d.addr).toUpperCase();
    const idx = d.idx ?? i;
    if (connectedByAddr.has(key)) {
      const row = connectedByAddr.get(key);
      if ((!row.name || row.name === "Unknown") && d.name) row.name = d.name;
      if (d.rssi != null) row.rssi = d.rssi;
      if (d.last_s != null) row.last_s = d.last_s;
      row.idx = idx;
    }
  });

  const connected = [...connectedByAddr.values()].sort((a, b) => (a.slot ?? 99) - (b.slot ?? 99));
  const discovered = [];
  devices.forEach((d, i) => {
    if (!d?.addr) return;
    const key = String(d.addr).toUpperCase();
    if (connectedByAddr.has(key) || d.connected) return;
    discovered.push({...d, idx: d.idx ?? i});
  });
  return {connected, discovered};
}

function renderConnectedDevices(list) {
  const ul = $("connectedDevicesList");
  ul.innerHTML = "";
  if (!list.length) {
    ul.innerHTML = "<li>None</li>";
    return;
  }
  list.forEach((d) => {
    const li = document.createElement("li");
    const slotText = Number.isFinite(d.slot) ? `Slot ${d.slot + 1}` : "Connected";
    li.innerHTML = `<strong>${slotText}</strong>: ${esc(d.name || "Unknown")} <span class="mono">${esc(d.addr)}</span> (${d.ble ? "BLE" : "Classic"}, RSSI ${d.rssi}, last ${d.last_s}s)`;
    ul.appendChild(li);
  });
}

function renderPaired() {
  const ul = $("paired");
  ul.innerHTML = "";
  const arr = state?.bt?.paired || [];
  if (!arr.length) { ul.innerHTML = "<li>None</li>"; return; }
  arr.forEach((p) => {
    const li = document.createElement("li");
    li.innerHTML = `<span class="mono">${esc(p.addr)}</span> (type ${p.type})`;
    ul.appendChild(li);
  });
}

function renderWiFiClients() {
  const ul = $("wifiClients");
  ul.innerHTML = "";
  if (!state?.wifi?.ap) {
    ul.innerHTML = "<li>AP not started</li>";
    return;
  }
  const arr = state?.wifi?.clients || [];
  if (!arr.length) {
    ul.innerHTML = "<li>None</li>";
    return;
  }
  arr.forEach((c) => {
    const li = document.createElement("li");
    li.innerHTML = `${esc(c.mac)} - ${esc(c.ip)} (last ${c.last_s}s)`;
    ul.appendChild(li);
  });
}

function renderWol() {
  const ul = $("wolList");
  ul.innerHTML = "";
  const arr = state?.wol?.machines || [];
  if (!arr.length) {
    ul.innerHTML = "<li>None</li>";
    return;
  }
  arr.forEach((m, i) => {
    const li = document.createElement("li");
    const displayName = m.name || ("Machine " + (i + 1));
    li.innerHTML = `<strong>${esc(displayName)}</strong> <span class="mono">${esc(m.mac || "-")}</span>`;
    const row = document.createElement("div");
    row.className = "row";
    const sendBtn = document.createElement("button");
    sendBtn.textContent = "Send WOL";
    sendBtn.onclick = () => runWrap(async () => {
      await runCmd(`/wol/send/${i}`);
    });
    const upBtn = document.createElement("button");
    upBtn.textContent = "Up";
    upBtn.onclick = () => runWrap(async () => {
      await runCmd(`/wol/move/${i}/up`);
      await refreshState(true);
      renderAll();
    });
    const downBtn = document.createElement("button");
    downBtn.textContent = "Down";
    downBtn.onclick = () => runWrap(async () => {
      await runCmd(`/wol/move/${i}/down`);
      await refreshState(true);
      renderAll();
    });
    const delBtn = document.createElement("button");
    delBtn.className = "warn";
    delBtn.textContent = "Delete";
    delBtn.onclick = () => runWrap(async () => {
      await runCmd(`/wol/delete/${i}`);
      await refreshState(true);
      renderAll();
    });
    row.appendChild(sendBtn);
    row.appendChild(upBtn);
    row.appendChild(downBtn);
    row.appendChild(delBtn);
    li.appendChild(row);
    ul.appendChild(li);
  });
}

function loadLogs() {
  try {
    const parsed = JSON.parse(localStorage.getItem(LOG_STORE_KEY) || "[]");
    if (Array.isArray(parsed)) logLines = parsed;
  } catch (_) {
    logLines = [];
  }
}

function saveLogs() {
  try {
    localStorage.setItem(LOG_STORE_KEY, JSON.stringify(logLines.slice(-LOG_MAX)));
  } catch (_) {}
}

function appendLogsFromState() {
  if (!state) return;
  if (state.uptime_s !== undefined && state.uptime_s < 5) {
    logLines = [];
    lastLogSeq = 0;
  }
  if (!Array.isArray(state.logs) || state.logs.length === 0) return;
  const firstSeq = Number(state.log_first_seq || 0);
  let seq = firstSeq;
  for (const line of state.logs) {
    if (seq > lastLogSeq) {
      logLines.push({ s: seq, l: String(line) });
      lastLogSeq = seq;
    }
    seq++;
  }
  if (logLines.length > LOG_MAX) {
    logLines = logLines.slice(logLines.length - LOG_MAX);
  }
  saveLogs();
}

function renderLogs() {
  const box = $("logBox");
  if (!box) return;
  if (!logLines.length) {
    box.innerHTML = "None";
    $("logMeta").textContent = "No logs yet";
    return;
  }
  const start = Math.max(0, logLines.length - LOG_RENDER_MAX);
  const lines = [];
  for (let i = logLines.length - 1; i >= start; i--) {
    const row = logLines[i];
    lines.push(esc(row.l || String(row)));
  }
  box.innerHTML = lines.join("<br>");
  $("logMeta").textContent = `${logLines.length} stored lines`;
}

function renderControllerPads() {
  const root = $("controllerPads");
  if (!root || root.dataset.ready === "1") return;
  root.dataset.ready = "1";
  for (let gp = 0; gp < 4; gp++) {
    const pad = document.createElement("div");
    pad.className = "pad";
    const title = document.createElement("h3");
    title.textContent = `Controller ${gp + 1}`;
    pad.appendChild(title);
    const row = document.createElement("div");
    row.className = "row";
    VIRTUAL_BUTTONS.forEach(([name, id]) => {
      const b = document.createElement("button");
      b.textContent = name;
      b.onclick = () => runWrap(async () => {
        await runCmd(`/gp/${gp}/btn/${id}`);
      });
      row.appendChild(b);
    });
    const reset = document.createElement("button");
    reset.textContent = "Reset";
    reset.onclick = () => runWrap(async () => {
      await runCmd(`/gp/${gp}/reset`);
    });
    row.appendChild(reset);
    pad.appendChild(row);
    root.appendChild(pad);
  }
}

function renderSlots() {
  const list = $("slots");
  list.innerHTML = "";
  let outputs = state?.bt?.outputs;
  if (!Array.isArray(outputs) || !outputs.length) {
    // BLE merged state may not include canonical outputs; derive them from slots.
    const fromSlots = Array.isArray(state?.bt?.slots) ? state.bt.slots : [];
    const bySlot = new Array(4).fill(null).map((_, i) => ({
      slot: i,
      connected: 0,
      src: "none",
      sid: i,
      ble: 0,
      last_s: 0,
      name: "",
      addr: "",
    }));
    fromSlots.forEach((s) => {
      const map = Number(s?.map);
      if (!Number.isFinite(map) || map < 0 || map > 3 || !s?.connected) return;
      const cur = bySlot[map];
      const src = s?.src || "bt";
      const next = {
        slot: map,
        connected: 1,
        src,
        sid: Number.isFinite(Number(s?.id)) ? Number(s.id) : map,
        ble: s?.ble ? 1 : 0,
        last_s: Number(s?.last_s || 0),
        name: s?.name || (src === "wifi" ? "WiFi Controller" : "BT Controller"),
        addr: s?.addr || "",
      };
      // Prefer WiFi row if mixed duplicates exist in fallback path.
      if (!cur.connected || (cur.src !== "wifi" && next.src === "wifi")) {
        bySlot[map] = next;
      }
    });
    outputs = bySlot;
  }
  outputs = [...outputs].sort((a,b) => (a.slot - b.slot));
  if (!outputs.length) { list.innerHTML = "<li>None</li>"; return; }
  outputs.forEach((s) => {
    const li = document.createElement("li");
    li.className = "slot-item";
    li.draggable = !!s.connected;
    li.dataset.slotId = String(s.slot);
    const name = (s.name || "").trim() || "Unknown";
    const src = s.src === "wifi" ? "WiFi" : (s.src === "bt" ? (s.ble ? "BLE" : "Classic BT") : "None");
    li.innerHTML = `<div class="slot-top"><strong>Slot ${s.slot + 1}: ${s.connected ? esc(name) : "Empty"}</strong><span class="pill ${s.connected ? "ok" : ""}">${s.connected ? "Connected" : "Empty"}</span></div><div class="small">${s.connected ? `${src} ${esc(s.addr)} | last ${s.last_s}s` : "No controller"}</div>`;
    li.addEventListener("dragstart", () => { dragFromSlot = s.connected ? Number(li.dataset.slotId) : null; });
    li.addEventListener("dragover", (e) => { e.preventDefault(); li.classList.add("over"); });
    li.addEventListener("dragleave", () => li.classList.remove("over"));
    li.addEventListener("drop", (e) => {
      e.preventDefault();
      li.classList.remove("over");
      runWrap(() => reorder(dragFromSlot, Number(li.dataset.slotId)));
    });
    list.appendChild(li);
  });
}

async function reorder(from, to) {
  if (from == null || to == null || from === to) return;
  if (to > from) {
    for (let i = from; i < to; i++) await runCmd(`/bt/order_output/${i}/down`);
  } else {
    for (let i = from; i > to; i--) await runCmd(`/bt/order_output/${i}/up`);
  }
  await refreshState(true);
}

function renderAll() {
  updateTop();
  renderDevices();
  renderPaired();
  renderWiFiClients();
  renderWol();
  renderSlots();
  renderControllerPads();
  renderLogs();
}

async function refreshState(full) {
  const via = $("controlVia").value;
  if (via === "wifi") {
    if (isMixedContentBlocked()) {
      throw new Error("Wi-Fi transport blocked by HTTPS mixed-content policy. Use BLE or set Device URL to https.");
    }
    state = await httpStatusFetch();
    setHttpOnline(true);
    return;
  }
  if (via === "ble") {
    if (!bleIsConnected()) {
      await bleTryAutoConnect().catch(() => {});
    }
    if (!bleIsConnected()) {
      ensureStateDefaults();
      return;
    }
    state = await bleStatusFetch(full);
    return;
  }
  if (isMixedContentBlocked()) {
    if (!bleIsConnected()) {
      await bleTryAutoConnect().catch(() => {});
    }
    if (!bleIsConnected()) {
      ensureStateDefaults();
      return;
    }
    state = await bleStatusFetch(full);
    return;
  }
  try {
    state = await httpStatusFetch();
    setHttpOnline(true);
  } catch (e) {
    setHttpOnline(false);
    if (!bleIsConnected()) throw e;
    state = await bleStatusFetch(full);
  }
}

async function pollTick() {
  if (pollInFlight) return;
  pollInFlight = true;
  try {
    if (!bleIsConnected() && (effectiveTransport() !== "wifi")) {
      const now = Date.now();
      if ((now - bleLastAutoAttemptMs) > 5000) {
        bleLastAutoAttemptMs = now;
        await bleTryAutoConnect().catch(() => {});
      }
    }
    if (captureActive && effectiveTransport() === "ble") {
      setBleOnline(bleIsConnected());
      return;
    }
    await refreshState(false);
    if (!logsPaused) {
      appendLogsFromState();
    }
    renderAll();
    if (!bleIsConnected() && (effectiveTransport() === "ble" || isMixedContentBlocked())) {
      if (!bleAutoReconnectSupported()) {
        setError("Auto BLE reconnect is not supported in this browser. Use Connect BLE after each reload.");
      } else {
        setError("Waiting for BLE reconnect...");
      }
    } else {
      setError("");
    }
    if (bleIsConnected()) {
      await bleRefreshPanel().catch(() => {});
    }
  } catch (e) {
    if (!httpOnline) setHttpOnline(false);
    setError(String(e));
  } finally {
    pollInFlight = false;
  }
}

function startPolling() {
  if (pollTimer) clearInterval(pollTimer);
  pollEnabled = true;
  $("pollBtn").textContent = "Polling On";
  $("pollBtn").className = "ok";
  pollTick();
  pollTimer = setInterval(pollTick, 1200);
}

function stopPolling() {
  pollEnabled = false;
  if (pollTimer) clearInterval(pollTimer);
  pollTimer = null;
  $("pollBtn").textContent = "Polling Off";
  $("pollBtn").className = "warn";
}

async function runWrap(fn) {
  try { await fn(); setError(""); } catch (e) { setError(String(e)); }
}

function parseBleControllers(view) {
  const out = [];
  const len = 16;
  const hex2 = (v) => v.toString(16).toUpperCase().padStart(2, "0");
  for (let off = 0; off + len <= view.byteLength; off += len) {
    const idx = view.getUint8(off + 0);
    const b = new Uint8Array(view.buffer, view.byteOffset + off + 1, 6);
    const addr = [...b].map(hex2).join(":");
    const vid = view.getUint16(off + 7, true);
    const pid = view.getUint16(off + 9, true);
    const st = view.getUint8(off + 11);
    out.push({idx, addr, vid, pid, st});
  }
  return out.filter((x) => x.st !== 0);
}

function renderBleControllers(items) {
  const ul = $("bleControllers");
  ul.innerHTML = "";
  if (!items.length) { ul.innerHTML = "<li>None</li>"; return; }
  items.forEach((it) => {
    const li = document.createElement("li");
    li.innerHTML = `Slot ${it.idx}: <span class="mono">${it.addr}</span> (VID:PID ${it.vid.toString(16).padStart(4,"0")}:${it.pid.toString(16).padStart(4,"0")})`;
    ul.appendChild(li);
  });
}

async function bleConnect() {
  let device = null;
  try {
    device = await navigator.bluetooth.requestDevice({
      filters: [
        { services: [UUIDS.service] },
        ...BLE_NAME_PREFIXES.map((namePrefix) => ({ namePrefix })),
      ],
      optionalServices: [UUIDS.service],
    });
  } catch (e) {
    // Some adapters/controllers won't expose the custom service UUID in
    // advertising data. Fall back to a generic chooser.
    if (!e || e.name !== "NotFoundError") {
      throw e;
    }
    device = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,
      optionalServices: [UUIDS.service],
    });
  }
  bleManualDisconnect = false;
  await bleAttach(device);
}

function bleDisconnect() {
  bleManualDisconnect = true;
  clearBleAutoReconnectTimer();
  if (bleDevice && bleDevice.gatt.connected) bleDevice.gatt.disconnect();
  setBleOnline(false);
  renderBleControllers([]);
  bleServer = null;
  bleChars = {};
}

async function bleRefreshPanel() {
  if (!bleIsConnected()) return;
  const raw = await bleSerialize(async () => bleChars.connectedDevices.readValue());
  renderBleControllers(parseBleControllers(raw));
}

function bind() {
  $("baseUrl").value = baseUrl;
  $("controlVia").value = controlVia;

  $("saveUrlBtn").onclick = () => {
    baseUrl = normalizeBaseUrl($("baseUrl").value);
    $("baseUrl").value = baseUrl;
    localStorage.setItem("pico_manager_url", baseUrl);
    if (isMixedContentBlocked()) {
      setError("HTTPS page cannot call http:// device URL. Use https:// tunnel URL or BLE transport.");
    } else {
      setError("");
    }
  };
  $("controlVia").onchange = () => {
    controlVia = $("controlVia").value;
    localStorage.setItem("pico_manager_via", controlVia);
    runWrap(async () => {
      if (controlVia === "ble" || controlVia === "auto") {
        await bleTryAutoConnect().catch(() => {});
      }
      await refreshState(true);
      renderAll();
    });
  };
  $("testBtn").onclick = () => runWrap(async () => { await refreshState(true); renderAll(); });
  $("pollBtn").onclick = () => pollEnabled ? stopPolling() : startPolling();
  $("modeSelect").onchange = () => { modeSelectDirty = true; };

  $("modeSetBtn").onclick = () => runWrap(async () => {
    const targetMode = $("modeSelect").value;
    modeSetPending = targetMode;
    modeSelectDirty = false;
    const resp = await runCmd(`/mode/${targetMode}`);
    setError(resp?.reboot ? "Mode switch requested; device will reboot."
                          : "Mode switch requested.");
  });
  $("usbWakeBtn").onclick = () => runWrap(async () => {
    await runCmd("/usb/wake");
  });
  $("usbSleepBtn").onclick = () => runWrap(async () => {
    await runCmd("/usb/sleep");
  });
  $("swapOnBtn").onclick = () => runWrap(async () => {
    await runCmd("/switch/abxy/1");
    await refreshState(true);
    renderAll();
  });
  $("swapOffBtn").onclick = () => runWrap(async () => {
    await runCmd("/switch/abxy/0");
    await refreshState(true);
    renderAll();
  });

  $("captureBtn").onclick = () => runWrap(async () => {
    captureActive = true;
  });
  $("releaseCaptureBtn").onclick = () => runWrap(stopCapture);
  $("leftClickBtn").onclick = () => runWrap(() => mkClick(1));
  $("rightClickBtn").onclick = () => runWrap(() => mkClick(2));
  $("middleClickBtn").onclick = () => runWrap(() => mkClick(3));
  $("mkSendTextBtn").onclick = () => runWrap(async () => {
    await mkSendText($("mkTextIn").value || "");
    $("mkTextIn").value = "";
  });

  const pad = $("touchpad");
  pad.addEventListener("pointerdown", touchpadDown);
  pad.addEventListener("pointermove", touchpadMove);
  pad.addEventListener("pointerup", touchpadUp);
  pad.addEventListener("pointercancel", touchpadUp);
  pad.addEventListener("pointerleave", touchpadUp);

  $("scanOnBtn").onclick = () => runWrap(async () => { await runCmd("/bt/scan/1"); await refreshState(true); renderAll(); });
  $("scanOffBtn").onclick = () => runWrap(async () => { await runCmd("/bt/scan/0"); await refreshState(true); renderAll(); });
  $("scanClearBtn").onclick = () => runWrap(async () => { await runCmd("/bt/scan/clear"); await refreshState(true); renderAll(); });
  $("autoOnBtn").onclick = () => runWrap(async () => { await runCmd("/bt/autoconnect/1"); await refreshState(true); renderAll(); });
  $("autoOffBtn").onclick = () => runWrap(async () => { await runCmd("/bt/autoconnect/0"); await refreshState(true); renderAll(); });
  $("showOnBtn").onclick = () => runWrap(async () => { await runCmd("/bt/showall/1"); await refreshState(true); renderAll(); });
  $("showOffBtn").onclick = () => runWrap(async () => { await runCmd("/bt/showall/0"); await refreshState(true); renderAll(); });
  $("pairListBtn").onclick = () => runWrap(async () => { await runCmd("/bt/listpair"); await refreshState(true); renderAll(); });
  $("pairClearBtn").onclick = () => runWrap(async () => { await runCmd("/bt/clearpair"); await refreshState(true); renderAll(); });

  $("wifiSetBtn").onclick = () => runWrap(async () => {
    const ssid = encodeURIComponent($("wifiSsidIn").value || "");
    const pass = encodeURIComponent($("wifiPassIn").value || "");
    await runCmd(`/wifi/set?ssid=${ssid}&pass=${pass}`);
    await refreshState(true);
    renderAll();
  });
  $("wifiReconnectBtn").onclick = () => runWrap(async () => {
    await runCmd("/wifi/reconnect");
    await refreshState(true);
    renderAll();
  });

  $("wolAddBtn").onclick = () => runWrap(async () => {
    const name = encodeURIComponent($("wolNameIn").value || "");
    const mac = encodeURIComponent($("wolMacIn").value || "");
    await runCmd(`/wol/add?name=${name}&mac=${mac}`);
    $("wolNameIn").value = "";
    $("wolMacIn").value = "";
    await refreshState(true);
    renderAll();
  });
  $("wolSendFirstBtn").onclick = () => runWrap(async () => {
    await runCmd("/wol/send/0");
  });
  $("wolWakeBtn").onclick = () => runWrap(async () => {
    await runCmd("/usb/wake");
  });

  $("bleConnectBtn").onclick = () => runWrap(bleConnect);
  $("bleDisconnectBtn").onclick = bleDisconnect;
  $("bleRefreshBtn").onclick = () => runWrap(async () => {
    await bleRefreshPanel();
    if ($("controlVia").value !== "wifi") {
      await refreshState(true);
      renderAll();
    }
  });
  $("logPauseBtn").onclick = () => {
    logsPaused = !logsPaused;
    $("logPauseBtn").textContent = logsPaused ? "Resume" : "Pause";
  };
  $("logClearBtn").onclick = () => {
    logLines = [];
    lastLogSeq = 0;
    saveLogs();
    renderLogs();
  };

  window.addEventListener("keydown", captureKeyDown, {passive: false});
  window.addEventListener("keyup", captureKeyUp, {passive: false});
  window.addEventListener("mousemove", captureMouseMove, {passive: true});
  window.addEventListener("wheel", captureMouseWheel, {passive: false});
  window.addEventListener("mousedown", (e) => captureMouseButton(e, true), {passive: false});
  window.addEventListener("mouseup", (e) => captureMouseButton(e, false), {passive: false});
}

bind();
loadLogs();
startPolling();
runWrap(async () => { await bleTryAutoConnect(); });
setInterval(() => { mkFlushMotion(); }, 20);
</script>
</body>
</html>
